<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8">
  <title>Program Enkripsi – Dekripsi Multi-Cipher</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    textarea { width: 100%; height: 100px; }
    input[type="text"], input[type="number"] { width: 100%; padding: 5px; }
    .section { margin-bottom: 20px; }
    label { font-weight: bold; }
    .matrix-input { width: 50px; }
  </style>
</head>
<body>
  <h1>Program Enkripsi – Dekripsi Multi-Cipher</h1>
  <div class="section">
    <label for="cipherSelect">Pilih Cipher:</label>
    <select id="cipherSelect">
      <option value="vigenere">Vigenere Standard</option>
      <option value="autokey">Auto-Key Vigenere</option>
      <option value="extended">Extended Vigenere</option>
      <option value="affine">Affine Cipher</option>
      <option value="playfair">Playfair Cipher</option>
      <option value="hill">Hill Cipher (2x2)</option>
    </select>
  </div>

  <div class="section">
    <label for="keyInput">Kunci:</label>
    <input type="text" id="keyInput" placeholder="Masukkan kunci (atau untuk Affine: a,b atau Hill: masukkan angka dipisahkan koma)">
    <small>Untuk Affine Cipher, masukkan dua bilangan, contoh: 5,8. Untuk Hill Cipher, masukkan matriks 2x2 dengan 4 angka, contoh: 3,3,2,5.</small>
  </div>

  <div class="section">
    <label>Pesan (Plaintext/Ciphertext):</label>
    <textarea id="textInput" placeholder="Tulis pesan di sini atau upload file..."></textarea>
    <br>
    <input type="file" id="fileInput">
  </div>

  <div class="section">
    <label>Tampilan Cipherteks:</label>
    <select id="cipherTextFormat">
      <option value="none">Tanpa spasi</option>
      <option value="group5">Kelompok 5-huruf</option>
    </select>
  </div>

  <div class="section">
    <button onclick="processEncryption()">Enkripsi</button>
    <button onclick="processDecryption()">Dekripsi</button>
    <button onclick="downloadText()">Simpan Cipherteks ke File</button>
  </div>

  <div class="section">
    <label>Output Enkripsi:</label>
    <textarea id="outputArea" readonly></textarea>
  </div>

  <script>
    // Fungsi pembantu: Normalisasi teks untuk cipher yang hanya memakai A-Z
    function normalizeText(text) {
      return text.toUpperCase().replace(/[^A-Z]/g, '');
    }

    // Fungsi pembantu: Membagi string ke kelompok 5-huruf
    function formatInGroups(text) {
      return text.match(/.{1,5}/g).join(' ');
    }

    // Vigenere Cipher Standar
    function vigenereEncrypt(plaintext, key) {
      plaintext = normalizeText(plaintext);
      key = normalizeText(key);
      let cipher = '';
      for (let i = 0; i < plaintext.length; i++) {
        let p = plaintext.charCodeAt(i) - 65;
        let k = key.charCodeAt(i % key.length) - 65;
        let c = (p + k) % 26;
        cipher += String.fromCharCode(c + 65);
      }
      return cipher;
    }
    function vigenereDecrypt(ciphertext, key) {
      ciphertext = normalizeText(ciphertext);
      key = normalizeText(key);
      let plaintext = '';
      for (let i = 0; i < ciphertext.length; i++) {
        let c = ciphertext.charCodeAt(i) - 65;
        let k = key.charCodeAt(i % key.length) - 65;
        let p = (c - k + 26) % 26;
        plaintext += String.fromCharCode(p + 65);
      }
      return plaintext;
    }

    // Auto-Key Vigenere Cipher
    function autoKeyEncrypt(plaintext, key) {
      plaintext = normalizeText(plaintext);
      key = normalizeText(key);
      // Kunci lengkap: kunci awal + sebagian plaintext
      let fullKey = key + plaintext;
      let cipher = '';
      for (let i = 0; i < plaintext.length; i++) {
        let p = plaintext.charCodeAt(i) - 65;
        let k = fullKey.charCodeAt(i) - 65;
        let c = (p + k) % 26;
        cipher += String.fromCharCode(c + 65);
      }
      return cipher;
    }
    function autoKeyDecrypt(ciphertext, key) {
      ciphertext = normalizeText(ciphertext);
      key = normalizeText(key);
      let plaintext = '';
      let fullKey = key;
      for (let i = 0; i < ciphertext.length; i++) {
        let c = ciphertext.charCodeAt(i) - 65;
        let k = fullKey.charCodeAt(i) - 65;
        let p = (c - k + 26) % 26;
        let pChar = String.fromCharCode(p + 65);
        plaintext += pChar;
        fullKey += pChar; // tambahkan plaintext ke kunci
      }
      return plaintext;
    }

    // Extended Vigenere Cipher (operasi pada byte, mod 256)
    function extendedVigenereEncrypt(inputBytes, key) {
      // key berupa string, ubah ke array byte
      let keyBytes = Array.from(key).map(c => c.charCodeAt(0));
      let output = new Uint8Array(inputBytes.length);
      for (let i = 0; i < inputBytes.length; i++) {
        output[i] = (inputBytes[i] + keyBytes[i % keyBytes.length]) % 256;
      }
      return output;
    }
    function extendedVigenereDecrypt(inputBytes, key) {
      let keyBytes = Array.from(key).map(c => c.charCodeAt(0));
      let output = new Uint8Array(inputBytes.length);
      for (let i = 0; i < inputBytes.length; i++) {
        output[i] = (inputBytes[i] - keyBytes[i % keyBytes.length] + 256) % 256;
      }
      return output;
    }

    // Affine Cipher
    function modInverse(a, m) {
      a = ((a % m) + m) % m;
      for (let x = 1; x < m; x++) {
        if ((a * x) % m === 1) return x;
      }
      return null; // tidak ada invers
    }
    function affineEncrypt(plaintext, a, b) {
      plaintext = normalizeText(plaintext);
      let cipher = '';
      for (let i = 0; i < plaintext.length; i++) {
        let p = plaintext.charCodeAt(i) - 65;
        let c = (a * p + b) % 26;
        cipher += String.fromCharCode(c + 65);
      }
      return cipher;
    }
    function affineDecrypt(ciphertext, a, b) {
      ciphertext = normalizeText(ciphertext);
      let inv = modInverse(a, 26);
      if (inv === null) {
        alert("Kunci 'a' tidak memiliki invers modulo 26.");
        return "";
      }
      let plaintext = '';
      for (let i = 0; i < ciphertext.length; i++) {
        let c = ciphertext.charCodeAt(i) - 65;
        let p = (inv * (c - b + 26)) % 26;
        plaintext += String.fromCharCode(p + 65);
      }
      return plaintext;
    }

    // Playfair Cipher
    function generatePlayfairTable(key) {
      key = normalizeText(key).replace(/J/g, 'I');
      let table = "";
      for (let i = 0; i < key.length; i++) {
        if (!table.includes(key[i])) table += key[i];
      }
      let alphabet = "ABCDEFGHIKLMNOPQRSTUVWXYZ";
      for (let c of alphabet) {
        if (!table.includes(c)) table += c;
      }
      return table;
    }
    function preparePlayfairText(text, forEncryption = true) {
      text = normalizeText(text).replace(/J/g, 'I');
      // Buat pasangan (digrams), sisipkan 'X' bila diperlukan
      let prepared = "";
      for (let i = 0; i < text.length; i++) {
        prepared += text[i];
        if (i === text.length - 1 || text[i] === text[i+1]) {
          prepared += "X";
        }
      }
      return prepared;
    }
    function playfairEncrypt(plaintext, key) {
      let table = generatePlayfairTable(key);
      plaintext = preparePlayfairText(plaintext);
      let cipher = "";
      for (let i = 0; i < plaintext.length; i += 2) {
        let a = plaintext[i], b = plaintext[i+1];
        let posA = table.indexOf(a), posB = table.indexOf(b);
        let rowA = Math.floor(posA / 5), colA = posA % 5;
        let rowB = Math.floor(posB / 5), colB = posB % 5;
        if (rowA === rowB) {
          // geser kanan
          cipher += table[rowA * 5 + (colA + 1) % 5];
          cipher += table[rowB * 5 + (colB + 1) % 5];
        } else if (colA === colB) {
          // geser ke bawah
          cipher += table[((rowA + 1) % 5) * 5 + colA];
          cipher += table[((rowB + 1) % 5) * 5 + colB];
        } else {
          // persegi panjang: tukar kolom
          cipher += table[rowA * 5 + colB];
          cipher += table[rowB * 5 + colA];
        }
      }
      return cipher;
    }
    // Catatan: Dekripsi Playfair memerlukan aturan yang sama tapi dengan pergeseran ke kiri/atas untuk baris/kolom.
    function playfairDecrypt(ciphertext, key) {
      let table = generatePlayfairTable(key);
      ciphertext = normalizeText(ciphertext);
      let plaintext = "";
      for (let i = 0; i < ciphertext.length; i += 2) {
        let a = ciphertext[i], b = ciphertext[i+1];
        let posA = table.indexOf(a), posB = table.indexOf(b);
        let rowA = Math.floor(posA / 5), colA = posA % 5;
        let rowB = Math.floor(posB / 5), colB = posB % 5;
        if (rowA === rowB) {
          plaintext += table[rowA * 5 + (colA + 4) % 5];
          plaintext += table[rowB * 5 + (colB + 4) % 5];
        } else if (colA === colB) {
          plaintext += table[((rowA + 4) % 5) * 5 + colA];
          plaintext += table[((rowB + 4) % 5) * 5 + colB];
        } else {
          plaintext += table[rowA * 5 + colB];
          plaintext += table[rowB * 5 + colA];
        }
      }
      return plaintext;
    }

    // Hill Cipher (contoh untuk matriks 2x2)
    function hillEncrypt(plaintext, matrix) {
      plaintext = normalizeText(plaintext);
      // Pastikan panjang plaintext genap
      if (plaintext.length % 2 !== 0)
        plaintext += "X";
      let cipher = "";
      for (let i = 0; i < plaintext.length; i += 2) {
        let vector = [plaintext.charCodeAt(i) - 65, plaintext.charCodeAt(i+1) - 65];
        let c0 = (matrix[0]*vector[0] + matrix[1]*vector[1]) % 26;
        let c1 = (matrix[2]*vector[0] + matrix[3]*vector[1]) % 26;
        cipher += String.fromCharCode((c0+26) % 26 + 65);
        cipher += String.fromCharCode((c1+26) % 26 + 65);
      }
      return cipher;
    }
    // Untuk dekripsi Hill, hitung invers matriks mod26 terlebih dahulu
    function hillDecrypt(ciphertext, matrix) {
      ciphertext = normalizeText(ciphertext);
      // Hitung determinan
      let det = (matrix[0]*matrix[3] - matrix[1]*matrix[2]) % 26;
      if(det < 0) det += 26;
      let detInv = modInverse(det, 26);
      if (detInv === null) {
        alert("Matriks kunci tidak dapat diinvers (determinannya tidak relatif prima dengan 26).");
        return "";
      }
      // Matriks invers = detInv * [m3, -m1, -m2, m0] mod 26
      let invMatrix = [
        (matrix[3]*detInv) % 26,
        ((-matrix[1])*detInv) % 26,
        ((-matrix[2])*detInv) % 26,
        (matrix[0]*detInv) % 26
      ].map(n => (n+26) % 26);
      
      let plaintext = "";
      for (let i = 0; i < ciphertext.length; i += 2) {
        let vector = [ciphertext.charCodeAt(i) - 65, ciphertext.charCodeAt(i+1) - 65];
        let p0 = (invMatrix[0]*vector[0] + invMatrix[1]*vector[1]) % 26;
        let p1 = (invMatrix[2]*vector[0] + invMatrix[3]*vector[1]) % 26;
        plaintext += String.fromCharCode((p0+26) % 26 + 65);
        plaintext += String.fromCharCode((p1+26) % 26 + 65);
      }
      return plaintext;
    }

    // Fungsi utama untuk enkripsi
    function processEncryption() {
      const cipherType = document.getElementById("cipherSelect").value;
      const keyInput = document.getElementById("keyInput").value;
      const textArea = document.getElementById("textInput");
      const formatOpt = document.getElementById("cipherTextFormat").value;
      const outputArea = document.getElementById("outputArea");

      // Jika file diunggah, baca file tersebut
      const file = document.getElementById("fileInput").files[0];
      if (file) {
        // Perlakuan khusus untuk Extended Vigenere Cipher (file of bytes)
        if (cipherType === "extended") {
          const reader = new FileReader();
          reader.onload = function(e) {
            let arrayBuffer = new Uint8Array(e.target.result);
            let encrypted = extendedVigenereEncrypt(arrayBuffer, keyInput);
            // Konversi ke string hex untuk ditampilkan
            let hexStr = Array.from(encrypted).map(b => b.toString(16).padStart(2, '0')).join('');
            outputArea.value = hexStr;
          }
          reader.readAsArrayBuffer(file);
          return;
        } else {
          // Untuk cipher lainnya, baca file teks
          const reader = new FileReader();
          reader.onload = function(e) {
            textArea.value = e.target.result;
            processEncryption(); // panggil ulang fungsi tanpa file
          }
          reader.readAsText(file);
          return;
        }
      }

      // Ambil pesan dari textarea
      let text = textArea.value;
      let result = "";
      switch(cipherType) {
        case "vigenere":
          result = vigenereEncrypt(text, keyInput);
          break;
        case "autokey":
          result = autoKeyEncrypt(text, keyInput);
          break;
        case "extended":
          // Untuk extended cipher pada teks, perlakukan sebagai rangkaian byte
          let bytes = new Uint8Array(Array.from(text).map(c => c.charCodeAt(0)));
          let encryptedBytes = extendedVigenereEncrypt(bytes, keyInput);
          // Tampilkan sebagai hex
          result = Array.from(encryptedBytes).map(b => b.toString(16).padStart(2, '0')).join('');
          break;
        case "affine":
          // Untuk affine, pisahkan kunci a,b
          var parts = keyInput.split(',').map(n => parseInt(n.trim()));
          if(parts.length < 2) { alert("Masukkan kunci Affine dengan format a,b"); return; }
          result = affineEncrypt(text, parts[0], parts[1]);
          break;
        case "playfair":
          result = playfairEncrypt(text, keyInput);
          break;
        case "hill":
          // Untuk Hill, kunci harus berupa 4 angka (untuk matriks 2x2)
          var parts = keyInput.split(',').map(n => parseInt(n.trim()));
          if(parts.length < 4) { alert("Masukkan 4 angka untuk matriks Hill (2x2) dipisahkan koma."); return; }
          result = hillEncrypt(text, parts);
          break;
        default:
          alert("Cipher tidak dikenal.");
      }
      if(formatOpt === "group5")
        result = formatInGroups(result);
      outputArea.value = result;
    }

    // Fungsi utama untuk dekripsi
    function processDecryption() {
      const cipherType = document.getElementById("cipherSelect").value;
      const keyInput = document.getElementById("keyInput").value;
      const textArea = document.getElementById("textInput");
      const outputArea = document.getElementById("outputArea");

      // Hilangkan spasi untuk cipher yang hanya memakai alfabet
      let text = textArea.value;
      if(cipherType !== "extended") {
        text = text.replace(/\s+/g, '');
      }
      let result = "";
      switch(cipherType) {
        case "vigenere":
          result = vigenereDecrypt(text, keyInput);
          break;
        case "autokey":
          result = autoKeyDecrypt(text, keyInput);
          break;
        case "extended":
          // Untuk extended cipher, asumsikan input berupa hex string
          let hex = text.trim();
          let bytes = new Uint8Array(hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
          let decryptedBytes = extendedVigenereDecrypt(bytes, keyInput);
          // Konversi ke karakter
          result = Array.from(decryptedBytes).map(b => String.fromCharCode(b)).join('');
          break;
        case "affine":
          var parts = keyInput.split(',').map(n => parseInt(n.trim()));
          if(parts.length < 2) { alert("Masukkan kunci Affine dengan format a,b"); return; }
          result = affineDecrypt(text, parts[0], parts[1]);
          break;
        case "playfair":
          result = playfairDecrypt(text, keyInput);
          break;
        case "hill":
          var parts = keyInput.split(',').map(n => parseInt(n.trim()));
          if(parts.length < 4) { alert("Masukkan 4 angka untuk matriks Hill (2x2) dipisahkan koma."); return; }
          result = hillDecrypt(text, parts);
          break;
        default:
          alert("Cipher tidak dikenal.");
      }
      outputArea.value = result;
    }

    // Fungsi untuk menyimpan output ke file
    function downloadText() {
      const output = document.getElementById("outputArea").value;
      const blob = new Blob([output], {type: "text/plain;charset=utf-8"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "hasil_cipher.txt";
      a.click();
      URL.revokeObjectURL(url);
    }
  </script>
</body>
</html>
